1.
 Процесс распространения событий (event propagation) в JavaScript описывает путь, по которому событие проходит внутри дерева DOM (Document Object Model).
 Этот механизм позволяет разработчику управлять обработчиками событий таким образом, чтобы они могли реагировать на события как в самом элементе,
 так который инициировал событие, так и в родительских элементах, включающих этот элемент.

 Распространение событий включает три основные фазы:
  1. Фаза захвата
  2. Фаза цели
  3. Фаза всплытия

 Способы применения знания фаз распространения событий на практике:
  Использование stopPropagation() и preventDefault()

2.
  Promise (обещание) — это объект в JavaScript, представляющий собой будущее значение результата асинхронной операции.
  Основная цель Promises заключается в упрощении управления асинхронностью, устраняя необходимость написания громоздких колбэков ("callback hell").

  Promise создается с использованием конструктора new Promise(executor).
  Параметры конструктора:
    resolve: Функция, которую нужно вызывать, когда операция успешно выполнена.
    reject: Функция, вызываемая при ошибке выполнения операции.

  Основные состояния Promise
  Каждый Promise имеет одно из трех состояний:
    Pending: Начальное состояние объекта Promise, означающее, что асинхронная операция ещё выполняется.
    Resolved: Операция завершилась успешно, и результат доступен.
    Rejected: Произошла ошибка, и выполнение прервано.

  Помимо Promises существуют и другие механизмы обработки асинхронности:
    1. Колбэки (Callbacks):Традиционный способ реализации асинхронных операций. Проблема с ними — неудобство чтения кода и сложность организации последовательных действий.
    2. Async/Await:Новый синтаксический сахар поверх Promises, позволяющий писать асинхронный код в синхронном стиле. Упрощает чтение и написание асинхронных алгоритмов.

  Роль Event Loop (цикл событий)
  Асинхронность в JavaScript реализуется благодаря особенностям движка V8 (используемого браузерами Chrome и Node.js):

  JS является однопоточным языком программирования, однако сам браузер/механизм исполнения поддерживает многопоточность.
  Асинхронные операции (сетевые запросы, таймауты, файловые операции) выполняются вне основного потока JavaScript и возвращаются обратно в очередь задач.
  Когда основной поток освобождается, очередь задач проверяется на наличие новых заданий и вызывает соответствующие колбэки/Promises.
  Эта система обеспечивает работу асинхронных операций параллельно основному потоку выполнения, сохраняя отзывчивость приложения.

3.
  Объектно-ориентированное программирование (ООП) — это парадигма программирования, основанная на концепции объектов, содержащих данные и методы, работающие с этими данными.
  Основная цель ООП заключается в упрощении разработки сложных приложений путем разделения программы на небольшие части (объекты),
  каждая из которых отвечает за выполнение определенных функций.

  Ключевые принципы ООП
    1. Инкапсуляция
       Инкапсуляция — это механизм сокрытия деталей реализации объекта внутри самого объекта.
       Внешним пользователям доступна лишь ограниченная функциональность, скрывающая внутреннюю реализацию.
       Пример: Представьте класс Person, содержащий свойства имени и возраста, а также метод вывода полного описания человека. Внутренняя реализация свойств скрыта от внешнего мира,
          и доступ осуществляется исключительно через публичные методы.

    2. Наследование
       Наследование позволяет создавать новые классы на основе существующих классов, наследуя их атрибуты и поведение.
       Это способствует повторному использованию кода и уменьшает дублирование.

    3. Абстракция
       Абстракция — процесс выделения общих характеристик и поведения объектов и игнорирования ненужных деталей.
       Она помогает сосредоточиться на главном, создавая абстрактные интерфейсы и классы.

  Реализация ООП в JavaScript
  JavaScript поддерживает объектно-ориентированный подход несколькими способами:

    1. Конструкторы и прототипы
       Это традиционный способ создания объектов в JavaScript, используя конструкторы и цепочку прототипов.
       Пример: Создание конструктора для объекта Person.
        // Определение конструктора
        function Person(name, age) {
             this.name = name;
             this.age = age;
        }
         // Добавление метода в прототип
        Person.prototype.greet = function () {
             console.log(`Hello, my name is ${this.name}`);
        };
        const person = new Person('John', 30);
        person.greet(); // Hello, my name is John

    2. Классы ES6+
      ES6 представил синтаксис классов. Этот подход делает код более читаемым и понятным.
      Пример: Использование классов для создания объекта Person.
        class Person {
          constructor(name, age) {
              this.name = name;
              this.age = age;
          }
          greet() {
             console.log(`Hello, my name is ${this.name}`);
          }
        }
        const person = new Person('Alice', 25);
        person.greet(); // Hello, my name is Alice

    3. Модули и модули экспорта
       Модульная система позволяет разделить приложение на отдельные файлы-модули, каждый из которых может содержать собственные объекты и классы.
       Пример: Разделение функциональности по модулям.
          // module.js
          export class ModuleClass {
            constructor(data) {
              this.data = data;
            }
            processData() {
              console.log(this.data);
            }
          }
          // main.js
          import { ModuleClass } from './module';

          const instance = new ModuleClass({ key: 'value' });
          instance.processData();

4.
  Этап 1: Анализ введенного URL
          При вводе URL, браузер сначала проверяет валидность введенной строки согласно спецификации URI (Uniform Resource Identifier).
          Например, проверяется наличие протокола (http://, https://), домена, пути и прочих элементов. Если строка верна, браузер отправляет запрос на дальнейшую обработку.

  Этап 2: Разрешение DNS (Domain Name System)
          Следующим этапом является преобразование имени хоста (например, example.com) в IP-адрес сервера.
          Это осуществляется посредством запросов к серверам DNS (Domain Name System).
          Браузер либо обращается к локальному кэшированному значению, либо запрашивает разрешение имени через провайдера интернет-услуг (ISP).
          DNS-запросы работают следующим образом:
            Проверка локального кеша: Проверяются записи, сохраненные ранее в операционной системе или самом браузере.
            Запрос роутеру: Если запись отсутствует в кешах, отправляется запрос домашнему роутеру.
            Обращение к DNS-серверу ISP: Роутер перенаправляет запрос ближайшему DNS-серверу интернет-провайдера.
            Иерархический поиск DNS-серверов: Запрос проходит по цепочке серверов верхнего уровня (root servers), которые направляют к нужному DNS-серверу зоны (.com, .org и т.п.).
            Получение IP-адреса: Получив нужный IP-адрес, браузер продолжает дальнейшее взаимодействие именно с ним.
          Этот этап существенно влияет на скорость загрузки страниц, особенно если запросы отправляются далеко расположенным DNS-серверам.

  Этап 3: Установка TCP/IP соединения
          После разрешения имени хоста в IP-адрес устанавливается соединение по протоколу TCP/IP.
          Обычно этот процесс выполняется на порте 80 (для HTTP) или 443 (для HTTPS). Для установки связи используются три этапа рукопожатия (TCP handshake):
            SYN — клиент отправляет SYN-пакет, сигнализируя желание установить связь.
            SYN+ACK — сервер подтверждает получение пакета и выражает согласие установить соединение.
            ACK — клиент окончательно подтверждает установление соединения.
          Затем устанавливается стабильное двухстороннее подключение, готовое передавать данные.

  Этап 4: SSL/TLS Handshake (если используется HTTPS)
          Перед передачей любого контента через HTTPS производится процедура шифрования соединений.
          Она обеспечивает безопасность передачи данных и защиту от перехвата информации злоумышленниками.

  Этап 5: Отправка HTTP-запроса
          Теперь, когда установленное соединение готово, браузер формирует и отправляет GET-запрос серверу.
          HTTP-заголовки содержат важную информацию, такую как тип браузера, принимаемые языки, предпочтения клиента относительно сжатия и прочее.

  Этап 6: Обработка ответа сервера
          Сервер принимает запрос и возвращает ответ вместе с HTML-кодом ресурса. Структура ответа также имеет заголовочную секцию и тело.
          После получения ответа браузер начинает разбор полученной разметки.

  Этап 7: Парсинг HTML-документа
          Браузер интерпретирует полученный HTML-код, создавая DOM (Document Object Model) — древообразную структуру документа, представляющую собой иерархическое представление всех элементов страницы.
          Эта структура позволяет быстро обращаться к любым элементам страницы.
          Процесс парсинга включает:
            - Чтение и интерпретацию тегов <html>, <head> и <body>.
            - Формирование дерева объектов DOM.
            - Поиск ссылок на внешние ресурсы (CSS-файлы, JavaScript, изображения и т.д.) для асинхронной загрузки.

  Этап 8: Загрузка ресурсов (CSS, JS, изображения)
          После формирования базовой структуры документа браузер параллельно загружает необходимые ресурсы, такие как CSS-стили, скрипты JavaScript и мультимедийные файлы.
          Эти процессы происходят одновременно благодаря современным технологиям, таким как параллельная загрузка и многопоточность.
          Проблемы, возникающие здесь:
            - Блокировка рендеринга: Некоторые ресурсы могут блокировать отображение страницы до полной загрузки (например, inline-JavaScript).
            - Междоменные ограничения (CORS): Ресурсы с другого домена могут требовать специальных разрешений для загрузки и исполнения.

  Этап 9: Интерпретация и выполнение JavaScript
          JavaScript код, встроенный непосредственно в HTML или подключаемый через внешний файл, запускается после его загрузки.
          Скрипты выполняют динамические изменения интерфейса, обработчики событий, манипуляции с элементами DOM и многое другое.

  Технологии ускорения процесса
  Современные браузеры используют целый спектр технологий для повышения производительности загрузки и отображения страниц:
    - Предсказательная предварительная обработка (Prefetching): Браузеры могут заранее начать разрешение DNS имен, установку TCP-соединений и даже предзагрузку некоторых ресурсов,
                                                                основываясь на предположениях о действиях пользователя.
    - Сжатие данных (Compression)
    - Многопоточность (Multi-threaded rendering): Современные браузеры разделяют разные части рендеринга на отдельные потоки,
                                                  позволяя быстрее обрабатывать большие объемы данных.
    - Lazy loading (Ленивая загрузка): Изображения и другие тяжелые элементы загружаются только тогда,
                                       когда они попадают в область видимости экрана, сокращая начальное время загрузки.
    - Кэширование (Caching): Часто используемые ресурсы сохраняются в кэше браузера или системы, исключая повторные обращения к сети.
    - Service Workers: Специализированные фоновые сервисы, позволяющие перехватывать запросы и отвечать на них прямо из кэша,
                       значительно улучшая производительность приложений PWA (Progressive Web Apps).

  Проблемы безопасности и междоменное взаимодействие
    Несмотря на эффективность современных подходов, существует несколько ключевых проблем, возникающих при обработке URL и взаимодействии браузера с сайтами:
      - Защита конфиденциальности пользователей: Важно избегать утечек личной информации через запросы к сторонним ресурсам или скрытые трекеры.
      - Атаки типа Man-in-the-Middle (MitM): Атака посредника возможна, если трафик передается незашифрованным способом (HTTP вместо HTTPS).
      - Политики CORS (Cross-Origin Resource Sharing): Ограничения кросс-доменного взаимодействия предотвращают несанкционированный доступ к данным и ресурсам разных доменов.
      - Cookie и сессии: Необходимо соблюдать правила безопасности при работе с cookie, защищая сессионные данные.
